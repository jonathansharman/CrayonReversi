import Game;
import Graphics2D;
import Graphics2DText;
import Math;
import Random;

const FPS = 30;
const X_RES = 400;
const Y_RES = 400;

const N = 8;
const MIN_VALUE = -1000000;
const MAX_VALUE = 1000000;

const CELL_WIDTH = X_RES / N;
const CELL_HEIGHT = Y_RES / N;

const CELL_PADDING = 5;

const BUTTON_PADDING = 10;
const BUTTON_BORDER = 3;
const SELECTOR_RADIUS = 30;

const MAX_AI_LEVEL = 6;

const EMPTY = 0;
const BLACK = 1;
const WHITE = -1;

enum GameState { SELECTOR, PLAYING }

class Input {
	field left_click = false;
	field left_arrow = false;
	field right_arrow = false;
	field down_arrow = false;
	field up_arrow = false;
	field enter = false;
	field mouse_x = 0;
	field mouse_y = 0;
	
	function update() {
		this.left_click = false;
		this.left_arrow = false;
		this.right_arrow = false;
		this.down_arrow = false;
		this.up_arrow = false;
		this.enter = false;
	}
}

function drawImageCentered(image, x, y) {
	left = x - image.width / 2;
	top = y - image.height / 2;
	image.draw(left, top);
}

function distanceSquared(p1, p2) {
	return (p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2;
}

function getSelectorText(player) {
	if (player == "human") {
		return "H";
	} else {
		return "AI " + player;
	}
}

function main() {
	window = new Game.GameWindow("Reversi", FPS, X_RES, Y_RES);
	input = new Input();

	titleFont = FontResource.fromResource('fonts/xolonium.ttf').getRenderer().setColor(255, 255, 255).setSize(48);
	whiteFont = FontResource.fromResource('fonts/xolonium.ttf').getRenderer().setColor(255, 255, 255).setSize(16);
	blackFont = FontResource.fromResource('fonts/xolonium.ttf').getRenderer().setColor(0, 0, 0).setSize(16);

	gameState = GameState.SELECTOR;
	// Each player is either "human" or an integer representing an AI level.
	players = ["human", MAX_AI_LEVEL / 2];

	titleImage = titleFont.render("Reversi");
	gameOverImage = whiteFont.render("Game Over");
	playButtonTextImage = whiteFont.render("Play!");
	tourneyButtonTextImage = whiteFont.render("Tourney");

	blackImage = whiteFont.render(getSelectorText(players[0]));
	whiteImage = blackFont.render(getSelectorText(players[1]));

	tourneyMode = true;
	blackWins = 0;
	matches = 0;

	programRunning = true;
	while (programRunning) {
		input.update();

		eventList = window.pumpEvents();
		for (i = 0; i < eventList.length; i++) {
			event = eventList[i];
			if (event.type == Game.EventType.QUIT) {
				programRunning = false;
			} else if (event.type == Game.EventType.KEY_DOWN) {
				if (event.key == Game.KeyboardKey.F2) {
					// Restart game and reset stats.
					blackWins = 0;
					matches = 0;
					gameState = GameState.SELECTOR;
				} else if (event.key == Game.KeyboardKey.LEFT) {
					input.left_arrow = true;
				} else if (event.key == Game.KeyboardKey.RIGHT) {
					input.right_arrow = true;
				} else if (event.key == Game.KeyboardKey.UP) {
					input.up_arrow = true;
				} else if (event.key == Game.KeyboardKey.DOWN) {
					input.down_arrow = true;
				} else if (event.key == Game.KeyboardKey.ENTER) {
					input.enter = true;
				}
			} else if (event.type == Game.EventType.MOUSE_LEFT_DOWN) {
				input.left_click = true;
			} else if (event.type == Game.EventType.MOUSE_MOVE) {
				input.mouse_x = event.x;
				input.mouse_y = event.y;
			}
		}

		if (gameState == GameState.SELECTOR) {
			playButtonLeft = X_RES / 2 - playButtonTextImage.width / 2 - BUTTON_PADDING;
			playButtonTop = Y_RES / 2 - playButtonTextImage.height / 2 - BUTTON_PADDING;
			playButtonWidth = playButtonTextImage.width + 2 * BUTTON_PADDING;
			playButtonHeight = playButtonTextImage.height + 2 * BUTTON_PADDING;

			tourneyButtonLeft = X_RES / 2 - tourneyButtonTextImage.width / 2 - BUTTON_PADDING;
			tourneyButtonTop = 3 * Y_RES / 4 - tourneyButtonTextImage.height / 2 - BUTTON_PADDING;
			tourneyButtonWidth = tourneyButtonTextImage.width + 2 * BUTTON_PADDING;
			tourneyButtonHeight = tourneyButtonTextImage.height + 2 * BUTTON_PADDING;

			hoveringPlay = true;
			hoveringPlay = hoveringPlay && input.mouse_x >= playButtonLeft;
			hoveringPlay = hoveringPlay && input.mouse_x < playButtonLeft + playButtonTextImage.width + 2 * BUTTON_PADDING;
			hoveringPlay = hoveringPlay && input.mouse_y >= playButtonTop;
			hoveringPlay = hoveringPlay && input.mouse_y < playButtonTop + playButtonTextImage.height + 2 * BUTTON_PADDING;

			hoveringTourney = true;
			hoveringTourney = hoveringTourney && input.mouse_x >= tourneyButtonLeft;
			hoveringTourney = hoveringTourney && input.mouse_x < tourneyButtonLeft + tourneyButtonTextImage.width + 2 * BUTTON_PADDING;
			hoveringTourney = hoveringTourney && input.mouse_y >= tourneyButtonTop;
			hoveringTourney = hoveringTourney && input.mouse_y < tourneyButtonTop + tourneyButtonTextImage.height + 2 * BUTTON_PADDING;

			if (input.left_click) {
				if (hoveringPlay) {
					reversi = new Reversi();
					gameState = GameState.PLAYING;
					tourneyMode = false;
				} else if (hoveringTourney) {
					reversi = new Reversi();
					gameState = GameState.PLAYING;
					tourneyMode = true;
					print(players[0] + " vs. " + players[1] + "!");
				} else if (distanceSquared([input.mouse_x, input.mouse_y], [X_RES / 4, Y_RES / 2]) < SELECTOR_RADIUS ** 2) {
					if (players[0] == "human") {
						players[0] = 0;
					} else if (players[0] == MAX_AI_LEVEL) {
						players[0] = "human";
					} else {
						++players[0];
					}
					blackImage = whiteFont.render(getSelectorText(players[0]));
				} else if (distanceSquared([input.mouse_x, input.mouse_y], [3 * X_RES / 4, Y_RES / 2]) < SELECTOR_RADIUS ** 2) {
					if (players[1] == "human") {
						players[1] = 0;
					} else if (players[1] == MAX_AI_LEVEL) {
						players[1] = "human";
					} else {
						++players[1];
					}
					whiteImage = blackFont.render(getSelectorText(players[1]));
				}
			}

			Graphics2D.Draw.fill(0, 128, 0);
			
			// Draw title.
			drawImageCentered(titleImage, X_RES / 2, Y_RES / 4);

			// Draw black selector.
			Graphics2D.Draw.ellipse
				( X_RES / 4 - SELECTOR_RADIUS
				, Y_RES / 2 - SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 0, 0, 0
				);
			drawImageCentered(blackImage, X_RES / 4, Y_RES / 2);

			// Draw white selector.
			Graphics2D.Draw.ellipse
				( 3 * X_RES / 4 - SELECTOR_RADIUS
				, Y_RES / 2 - SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 255, 255, 255
				);
			drawImageCentered(whiteImage, 3 * X_RES / 4, Y_RES / 2);

			// Draw play button.
			Graphics2D.Draw.rectangle
				( playButtonLeft
				, playButtonTop
				, playButtonWidth
				, playButtonHeight
				, 0, 0, 0
				);
			color = hoveringPlay ? [192, 192, 192] : [128, 128, 128];
			Graphics2D.Draw.rectangle
				( playButtonLeft + BUTTON_BORDER
				, playButtonTop + BUTTON_BORDER
				, playButtonWidth - 2 * BUTTON_BORDER
				, playButtonHeight - 2 * BUTTON_BORDER
				, color[0], color[1], color[2]
				);
			drawImageCentered(playButtonTextImage, X_RES / 2, Y_RES / 2);

			// Draw tourney button.
			Graphics2D.Draw.rectangle
				( tourneyButtonLeft
				, tourneyButtonTop
				, tourneyButtonWidth
				, tourneyButtonHeight
				, 0, 0, 0
				);
			color = hoveringTourney ? [192, 192, 192] : [128, 128, 128];
			Graphics2D.Draw.rectangle
				( tourneyButtonLeft + BUTTON_BORDER
				, tourneyButtonTop + BUTTON_BORDER
				, tourneyButtonWidth - 2 * BUTTON_BORDER
				, tourneyButtonHeight - 2 * BUTTON_BORDER
				, color[0], color[1], color[2]
				);
			drawImageCentered(tourneyButtonTextImage, X_RES / 2, 3 * Y_RES / 4);
		} else if (gameState == GameState.PLAYING) {
			if (reversi.gameOver) {
				scores = reversi.getScores();
				to_remove_total = Math.min(scores[BLACK], scores[WHITE]);
				to_remove = {EMPTY: 0, BLACK: to_remove_total, WHITE: to_remove_total};
				for (row = 0; row < N; ++row) {
					for (col = 0; col < N; ++col) {
						space = reversi.board[row][col];
						if (to_remove[space] > 0) {
							reversi.board[row][col] = 0;
							--to_remove[space];
						}
					}
				}

				if (tourneyMode) {
					// Log current standings and immediately restart.
					++matches;
					if (scores[BLACK] > scores[WHITE]) {
						++blackWins;
					}
					print(blackWins + "/" + matches + " (" + 100 * blackWins / matches + "%)");
					reversi = new Reversi();
					gameState = GameState.PLAYING;
				}
			} else {
				playerIdx = reversi.currentPlayer == BLACK ? 0 : 1;
				if (players[playerIdx] == "human") {
					// Player turn.
					if (reversi.validMoves.length > 0) {
						if (input.left_click) {
							move = [input.mouse_y / CELL_HEIGHT, input.mouse_x / CELL_WIDTH];
							reversi.play(move);
						}
					} else {
						// No valid moves. Pass.
						reversi.pass();
					}
				} else {
					// AI turn.
					lookahead = players[playerIdx] - 1;
					reversi.autoPlay(lookahead);
				}
			}
			reversi.draw();
		}
		window.clockTick();
	}
}
