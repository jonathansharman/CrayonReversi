import Game;
import Graphics2D;
import Math;
import Random;

const FPS = 30;
const X_RES = 400;
const Y_RES = 400;

const N = 8;

const CELL_WIDTH = X_RES / N;
const CELL_HEIGHT = Y_RES / N;

const CELL_PADDING = 5;

const MAX_LOOKAHEAD = 3;

// Fisher-Yates shuffle a list.
function shuffle(list) {
	for (i = 0; i < list.length - 1; ++i) {
		j = Random.randomInt(i, list.length);
		t = list[i];
		list[i] = list[j];
		list[j] = t;
	}
}

// An instance of a game of Reversi.
class Reversi {
	field board; // The game board as a 2D array of pieces: 0 for blank, 1 or -1 for a piece.
	field currentPlayer; // 1 or -1
	field passed; // Whether the previous move was a pass
	field gameOver; // Whether the game has ended (two consecutive passes)
	field validMoves; // The list of valid moves for the current player
	
	// Constructs a new instance of Reversi.
	constructor() {
		this.board = [];
		for (row = 0; row < N; ++row) {
			this.board.add([]);
			for (col = 0; col < N; ++col) {
				this.board[row].add(0);
			}
		}
		this.board[3][3] = -1;
		this.board[4][3] = 1;
		this.board[3][4] = 1;
		this.board[4][4] = -1;
		
		this.currentPlayer = 1;
		this.passed = false;
		this.gameOver = false;
		this.refreshValidMoves();
	}
	
	// Returns a deep copy of this game state.
	function clone() {
		newReversi = new Reversi();
		
		newReversi.board = [];
		for (i = 0; i < this.board.length; ++i) {
			newReversi.board.add(this.board[i].clone());
		}
		
		newReversi.currentPlayer = this.currentPlayer;
		newReversi.passed = this.passed;
		newReversi.gameOver = this.gameOver;
		
		newReversi.validMoves = [];
		for (i = 0; i < this.validMoves.length; ++i) {
			newReversi.validMoves.add(this.validMoves[i].clone());
		}

		return newReversi;
	}

	// Computes whether the given move is valid for the current player.
	function isValidMove(move) {
		row = move[0];
		col = move[1];
		if (this.board[row][col] != 0) {
			return false;
		}
		deltas = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];
		for (i = 0; i < deltas.length; ++i) {
			dRow = deltas[i][0];
			dCol = deltas[i][1];

			fRow = row + dRow;
			fCol = col + dCol;
			foundOther = false;
			while (fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == -this.currentPlayer) {
				foundOther = true;
				fRow += dRow;
				fCol += dCol;
			}			
			if (foundOther && fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == this.currentPlayer) {
				return true;
			}
		}
		return false;
	}
	
	// Refreshes the list of valid moves.
	function refreshValidMoves() {
		this.validMoves = [];
		for (row = 0; row < N; ++row) {
			for (col = 0; col < N; ++col) {
				if (this.isValidMove([row, col])) {
					this.validMoves.add([row, col]);
				}
			}
		}
	}
	
	// Computes the value of this game state for the given player.
	function getValue(player, lookahead) {
		if (lookahead == 0 || this.validMoves.length == 0) {
			scores = this.getScores();
			return scores[player] - scores[-player];
		} else {
			bestValue = this.clone().play(this.validMoves[0]).getValue(player, lookahead - 1);
			for (i = 1; i < this.validMoves.length; ++i) {
				currentValue = this.clone().play(this.validMoves[i]).getValue(player, lookahead - 1);
				if (currentValue > bestValue) {
					bestValue = currentValue;
				}
			}
			return bestValue;
		}
	}
	
	// Plays automatically for the current player.
	function autoPlay(lookahead) {
		if (this.validMoves.length == 0) {
			// No valid moves. Pass.
			this.pass();
		} else if (this.validMoves.length == 1) {
			// Only one option; no need to check its value.
			this.play(this.validMoves[0]);
		} else {
			// Find and play the best move.
			shuffle(this.validMoves); // Break ties randomly.
			bestMove = this.validMoves[0];
			bestValue = this.clone().play(bestMove).getValue(this.currentPlayer, lookahead);
			for (i = 1; i < this.validMoves.length; ++i) {
				currentValue = this.clone().play(this.validMoves[i]).getValue(this.currentPlayer, lookahead);
				if (currentValue > bestValue) {
					bestMove = this.validMoves[i];
					bestValue = currentValue;
				}
			}
			this.play(bestMove);
		}
	}
	
	// Causes the current player to attempt to play the given move. Returns this.
	function play(move) {
		row = move[0];
		col = move[1];
		if (this.isValidMove(move)) {
			deltas = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];
			for (i = 0; i < deltas.length; ++i) {
				dRow = deltas[i][0];
				dCol = deltas[i][1];
				
				fRow = row + dRow;
				fCol = col + dCol;
				foundOther = false;
				while (fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == -this.currentPlayer) {
					foundOther = true;
					fRow += dRow;
					fCol += dCol;
				}
				if (foundOther && fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == this.currentPlayer) {
					writeRow = row + dRow;
					writeCol = col + dCol;
					while (writeRow != fRow || writeCol != fCol) {
						this.board[writeRow][writeCol] = this.currentPlayer;
						writeRow += dRow;
						writeCol += dCol;
					}
				}
			}
			
			this.board[row][col] = this.currentPlayer;
			this.currentPlayer = -this.currentPlayer;
			
			this.passed = false;
			
			this.refreshValidMoves();
		}
		return this;
	}

	// Causes the current player to pass, ending the game if the previous player also passed. Returns this.
	function pass() {
		if (this.passed) {
			this.gameOver = true;
		} else {
			this.currentPlayer = -this.currentPlayer;
			this.passed = true;
			this.refreshValidMoves();
		}
		return this;
	}

	// Computes the number of pieces for each player as a dictionary from player to pieces.
	function getScores() {
		score = {1: 0, -1: 0};
		for (row = 0; row < N; ++row) {
			for (col = 0; col < N; ++col) {
				space = this.board[row][col];
				if (space != 0) {
					++score[space];
				}
			}
		}
		return score;
	}
	
	// Draws the game board and move hints.
	function draw() {
		Graphics2D.Draw.fill(0, 64, 0);
		// Draw the board and pieces.
		for (row = 0; row < N; ++row) {
			for (col = 0; col < N; ++col) {
				Graphics2D.Draw.rectangle(1 + col * CELL_WIDTH, 1 + row * CELL_HEIGHT, 48, 48, 0, 128, 0);
				if (this.board[row][col] != 0) {
					left = col * CELL_WIDTH + CELL_PADDING;
					top = row * CELL_HEIGHT + CELL_PADDING;
					width = CELL_WIDTH - 2 * CELL_PADDING;
					height = CELL_HEIGHT - 2 * CELL_PADDING;
					color = this.board[row][col] == 1 ? [0, 0, 0] : [255, 255, 255];
					Graphics2D.Draw.ellipse(left, top, width, height, color[0], color[1], color[2]);
				}
			}
		}
		// Draw valid moves.
		for (i = 0; i < this.validMoves.length; ++i) {
			row = this.validMoves[i][0];
			col = this.validMoves[i][1];
			color = this.currentPlayer == 1 ? [0, 96, 0] : [64, 160, 64];
			left = col * CELL_WIDTH + CELL_PADDING;
			top = row * CELL_HEIGHT + CELL_PADDING;
			width = CELL_WIDTH - 2 * CELL_PADDING;
			height = CELL_HEIGHT - 2 * CELL_PADDING;
			Graphics2D.Draw.ellipse(left, top, width, height, color[0], color[1], color[2]);
		}
	}
}

function main() {
	window = new Game.GameWindow("Reversi", FPS, X_RES, Y_RES);
	
	state = "menu";
	lookahead = 1;

	programRunning = true;
	while (programRunning) {
		input =
			{ "left click": false
			, "left arrow": false
			, "right arrow": false
			, "down arrow": false
			, "up arrow": false
			, "enter": false
			};
		click_x = 0;
		click_y = 0;
		scroll = 0;
		eventList = window.pumpEvents();
		for (i = 0; i < eventList.length; i++) {
			event = eventList[i];
			if (event.type == Game.EventType.QUIT) {
				programRunning = false;
			} else if (event.type == Game.EventType.KEY_DOWN) {
				if (event.key == Game.KeyboardKey.F2) {
					// Restart game.
					state = "menu";
				} else if (event.key == Game.KeyboardKey.LEFT) {
					input["left arrow"] = true;
				} else if (event.key == Game.KeyboardKey.RIGHT) {
					input["right arrow"] = true;
				} else if (event.key == Game.KeyboardKey.UP) {
					input["up arrow"] = true;
				} else if (event.key == Game.KeyboardKey.DOWN) {
					input["down arrow"] = true;
				} else if (event.key == Game.KeyboardKey.ENTER) {
					input["enter"] = true;
				}
			} else if (event.type == Game.EventType.MOUSE_LEFT_DOWN) {
				input["left click"] = true;
				click_x = event.x;
				click_y = event.y;
			} else if (event.type == Game.EventType.MOUSE_SCROLL) {
				scroll = event.amount;
			}
		}

		if (state == "menu") {
			if (input["left arrow"]) {
				--lookahead;
			}
			if (input["right arrow"]) {
				++lookahead;
			}
			if (input["up arrow"]) {
				++lookahead;
			}
			if (input["down arrow"]) {
				--lookahead;
			}
			lookahead += scroll;
			lookahead %= (MAX_LOOKAHEAD + 1);
			if (input["left click"] || input["enter"]) {
				reversi = new Reversi();
				state = "play";
			}
			// Draw menu.
			Graphics2D.Draw.fill(0, 128, 0);
			for (i = 0; i <= MAX_LOOKAHEAD; ++i) {
				left = X_RES / 2 + CELL_PADDING + (i - (MAX_LOOKAHEAD + 1) / 2.0) * CELL_WIDTH;
				top = Y_RES / 2 - CELL_HEIGHT / 2 + CELL_PADDING;
				width = CELL_WIDTH - 2 * CELL_PADDING;
				height = CELL_HEIGHT - 2 * CELL_PADDING;
				color = i <= lookahead ? [255, 255, 255] : [0, 0, 0];
				Graphics2D.Draw.ellipse(left, top, width, height, color[0], color[1], color[2]);
			}
		} else if (state == "play") {
			if (reversi.gameOver) {
				scores = reversi.getScores();
				to_remove_total = Math.min(scores[1], scores[-1]);
				to_remove = {0: 0, 1: to_remove_total, -1: to_remove_total};
				for (row = 0; row < N; ++row) {
					for (col = 0; col < N; ++col) {
						space = reversi.board[row][col];
						if (to_remove[space] > 0) {
							reversi.board[row][col] = 0;
							--to_remove[space];
						}
					}
				}
			} else {
				if (reversi.currentPlayer == -1) {
					// AI's turn.
					reversi.autoPlay(lookahead);
				} else if (reversi.currentPlayer == 1) {
					// Player's turn.
					if (reversi.validMoves.length > 0) {
						if (input["left click"]) {
							move = [click_y / CELL_HEIGHT, click_x / CELL_WIDTH];
							reversi.play(move);
						}
					} else {
						// No valid moves. Pass.
						reversi.pass();
					}
				}
			}
			reversi.draw();
		}
		window.clockTick();
	}
}
