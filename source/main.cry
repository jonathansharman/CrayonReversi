import Game;
import Graphics2D;
import Math;
import Random;

const FPS = 30;
const X_RES = 400;
const Y_RES = 400;

const N = 8;
const MIN_VALUE = -1000000;
const MAX_VALUE = 1000000;

const CELL_WIDTH = X_RES / N;
const CELL_HEIGHT = Y_RES / N;

const CELL_PADDING = 5;

const BUTTON_PADDING = 10;
const BUTTON_BORDER = 3;
const SELECTOR_RADIUS = 30;

const MAX_LOOKAHEAD = 4;

const EMPTY = 0;
const BLACK = 1;
const WHITE = -1;

enum GameState { SELECTOR, PLAYING }

function drawImageCentered(image, x, y) {
	left = x - image.width / 2;
	top = y - image.height / 2;
	image.draw(left, top);
}

function distanceSquared(p1, p2) {
	return (p2[0] - p1[0]) ** 2 + (p2[1] - p1[1]) ** 2;
}

function main() {
	window = new Game.GameWindow("Reversi", FPS, X_RES, Y_RES);

	gameState = GameState.SELECTOR;
	// Each player is either "human" or an integer representing an AI level.
	players = {BLACK: new Human(), WHITE: new NegamaxAI(MAX_LOOKAHEAD / 2)};

	titleImage = Font.title.render("Reversi");
	gameOverImage = Font.white.render("Game Over");
	playButtonTextImage = Font.white.render("Play!");
	tourneyButtonTextImage = Font.white.render("Tourney");

	blackImage = Font.white.render(players[BLACK].toString());
	whiteImage = Font.black.render(players[WHITE].toString());

	tourneyMode = true;
	blackWins = 0;
	matches = 0;

	programRunning = true;
	while (programRunning) {
		eventList = window.pumpEvents();
		Input.update(eventList);
		for (i = 0; i < eventList.length; i++) {
			event = eventList[i];
			if (event.type == Game.EventType.QUIT) {
				programRunning = false;
			}
		}

		if (Input.f2) {
			// Restart game and reset stats.
			blackWins = 0;
			matches = 0;
			gameState = GameState.SELECTOR;
		}

		if (gameState == GameState.SELECTOR) {
			playButtonLeft = X_RES / 2 - playButtonTextImage.width / 2 - BUTTON_PADDING;
			playButtonTop = Y_RES / 2 - playButtonTextImage.height / 2 - BUTTON_PADDING;
			playButtonWidth = playButtonTextImage.width + 2 * BUTTON_PADDING;
			playButtonHeight = playButtonTextImage.height + 2 * BUTTON_PADDING;

			tourneyButtonLeft = X_RES / 2 - tourneyButtonTextImage.width / 2 - BUTTON_PADDING;
			tourneyButtonTop = 3 * Y_RES / 4 - tourneyButtonTextImage.height / 2 - BUTTON_PADDING;
			tourneyButtonWidth = tourneyButtonTextImage.width + 2 * BUTTON_PADDING;
			tourneyButtonHeight = tourneyButtonTextImage.height + 2 * BUTTON_PADDING;

			hoveringPlay = true;
			hoveringPlay = hoveringPlay && Input.mouse_x >= playButtonLeft;
			hoveringPlay = hoveringPlay && Input.mouse_x < playButtonLeft + playButtonTextImage.width + 2 * BUTTON_PADDING;
			hoveringPlay = hoveringPlay && Input.mouse_y >= playButtonTop;
			hoveringPlay = hoveringPlay && Input.mouse_y < playButtonTop + playButtonTextImage.height + 2 * BUTTON_PADDING;

			hoveringTourney = true;
			hoveringTourney = hoveringTourney && Input.mouse_x >= tourneyButtonLeft;
			hoveringTourney = hoveringTourney && Input.mouse_x < tourneyButtonLeft + tourneyButtonTextImage.width + 2 * BUTTON_PADDING;
			hoveringTourney = hoveringTourney && Input.mouse_y >= tourneyButtonTop;
			hoveringTourney = hoveringTourney && Input.mouse_y < tourneyButtonTop + tourneyButtonTextImage.height + 2 * BUTTON_PADDING;

			if (Input.left_click) {
				if (hoveringPlay) {
					reversi = new Reversi();
					gameState = GameState.PLAYING;
					tourneyMode = false;
				} else if (hoveringTourney) {
					reversi = new Reversi();
					gameState = GameState.PLAYING;
					tourneyMode = true;
					print(players[BLACK].toString() + " vs. " + players[WHITE].toString() + "!");
				} else if (distanceSquared([Input.mouse_x, Input.mouse_y], [X_RES / 4, Y_RES / 2]) < SELECTOR_RADIUS ** 2) {
					name = players[BLACK].toString();
					if (name == "Human") {
						players[BLACK] = new RandomAI();
					} else if (name == "Bozo") {
						players[BLACK] = new NegamaxAI(0);
					} else if (players[BLACK].maxLookahead == MAX_LOOKAHEAD) {
						players[BLACK] = new Human();
					} else {
						++players[BLACK].maxLookahead;
					}
					blackImage = Font.white.render(players[BLACK].toString());
				} else if (distanceSquared([Input.mouse_x, Input.mouse_y], [3 * X_RES / 4, Y_RES / 2]) < SELECTOR_RADIUS ** 2) {
					name = players[WHITE].toString();
					if (name == "Human") {
						players[WHITE] = new RandomAI();
					} else if (name == "Bozo") {
						players[WHITE] = new NegamaxAI(0);
					} else if (players[WHITE].maxLookahead == MAX_LOOKAHEAD) {
						players[WHITE] = new Human();
					} else {
						++players[WHITE].maxLookahead;
					}
					whiteImage = Font.black.render(players[WHITE].toString());
				}
			}

			Graphics2D.Draw.fill(0, 128, 0);
			
			// Draw title.
			drawImageCentered(titleImage, X_RES / 2, Y_RES / 4);

			// Draw black selector.
			Graphics2D.Draw.ellipse
				( X_RES / 4 - SELECTOR_RADIUS
				, Y_RES / 2 - SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 0, 0, 0
				);
			drawImageCentered(blackImage, X_RES / 4, Y_RES / 2);

			// Draw white selector.
			Graphics2D.Draw.ellipse
				( 3 * X_RES / 4 - SELECTOR_RADIUS
				, Y_RES / 2 - SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 2 * SELECTOR_RADIUS
				, 255, 255, 255
				);
			drawImageCentered(whiteImage, 3 * X_RES / 4, Y_RES / 2);

			// Draw play button.
			Graphics2D.Draw.rectangle
				( playButtonLeft
				, playButtonTop
				, playButtonWidth
				, playButtonHeight
				, 0, 0, 0
				);
			color = hoveringPlay ? [192, 192, 192] : [128, 128, 128];
			Graphics2D.Draw.rectangle
				( playButtonLeft + BUTTON_BORDER
				, playButtonTop + BUTTON_BORDER
				, playButtonWidth - 2 * BUTTON_BORDER
				, playButtonHeight - 2 * BUTTON_BORDER
				, color[0], color[1], color[2]
				);
			drawImageCentered(playButtonTextImage, X_RES / 2, Y_RES / 2);

			// Draw tourney button.
			Graphics2D.Draw.rectangle
				( tourneyButtonLeft
				, tourneyButtonTop
				, tourneyButtonWidth
				, tourneyButtonHeight
				, 0, 0, 0
				);
			color = hoveringTourney ? [192, 192, 192] : [128, 128, 128];
			Graphics2D.Draw.rectangle
				( tourneyButtonLeft + BUTTON_BORDER
				, tourneyButtonTop + BUTTON_BORDER
				, tourneyButtonWidth - 2 * BUTTON_BORDER
				, tourneyButtonHeight - 2 * BUTTON_BORDER
				, color[0], color[1], color[2]
				);
			drawImageCentered(tourneyButtonTextImage, X_RES / 2, 3 * Y_RES / 4);
		} else if (gameState == GameState.PLAYING) {
			if (reversi.gameOver) {
				if (tourneyMode) {
					// Log current standings and immediately restart.
					scores = reversi.getScores();
					if (scores[BLACK] != scores[WHITE]) {
						++matches;
						if (scores[BLACK] > scores[WHITE]) {
							++blackWins;
						}
						print(blackWins + "/" + matches + " (" + 100 * blackWins / matches + "%)");
					}
					reversi = new Reversi();
					gameState = GameState.PLAYING;
				}
			} else {
				players[reversi.currentPlayer].autoPlay(reversi);
			}
			reversi.draw();
		}
		if (tourneyMode && matches > 0) {
			standingsImage = Font.white.render(blackWins + "/" + matches + " (" + 100 * blackWins / matches + "%)");
			Graphics2D.Draw.rectangle(0, 0, standingsImage.width, standingsImage.height, 0, 0, 0, 192);
			standingsImage.draw(0, 0);
		}
		window.clockTick();
	}
}
