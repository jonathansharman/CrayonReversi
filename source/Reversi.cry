import Graphics2D;
import Graphics2DText;
import Math;

// An instance of a game of Reversi.
class Reversi {
	field board; // The game board as a 2D array of pieces: EMPTY, BLACK, or WHITE.
	field currentPlayer; // BLACK or WHITE.
	field passed; // Whether the previous move was a pass.
	field gameOver; // Whether the game has ended (two consecutive passes).
	field validMoves; // The list of valid moves for the current player.

	constructor() {
		this.board = [];
		for (row = 0; row < N; ++row) {
			this.board.add([]);
			for (col = 0; col < N; ++col) {
				this.board[row].add(EMPTY);
			}
		}
		this.board[N / 2 - 1][N / 2 - 1] = WHITE;
		this.board[N / 2][N / 2 - 1] = BLACK;
		this.board[N / 2 - 1][N / 2] = BLACK;
		this.board[N / 2][N / 2] = WHITE;

		this.currentPlayer = BLACK;
		this.passed = false;
		this.gameOver = false;
		this.refreshValidMoves();
	}

	// Returns a deep copy of this game state.
	function clone() {
		newReversi = new Reversi();

		newReversi.board = [];
		for (i = 0; i < this.board.length; ++i) {
			newReversi.board.add(this.board[i].clone());
		}

		newReversi.currentPlayer = this.currentPlayer;
		newReversi.passed = this.passed;
		newReversi.gameOver = this.gameOver;

		newReversi.validMoves = [];
		for (i = 0; i < this.validMoves.length; ++i) {
			newReversi.validMoves.add(this.validMoves[i].clone());
		}

		return newReversi;
	}

	// Computes whether the given move is valid for the current player.
	function isValidMove(move) {
		row = move[0];
		col = move[1];
		if (this.board[row][col] != 0) {
			return false;
		}
		deltas = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];
		for (i = 0; i < deltas.length; ++i) {
			dRow = deltas[i][0];
			dCol = deltas[i][1];

			fRow = row + dRow;
			fCol = col + dCol;
			foundOther = false;
			while (fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == -this.currentPlayer) {
				foundOther = true;
				fRow += dRow;
				fCol += dCol;
			}			
			if (foundOther && fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == this.currentPlayer) {
				return true;
			}
		}
		return false;
	}

	// Refreshes the list of valid moves.
	function refreshValidMoves() {
		this.validMoves = [];
		for (row = 0; row < N; ++row) {
			for (col = 0; col < N; ++col) {
				if (this.isValidMove([row, col])) {
					this.validMoves.add([row, col]);
				}
			}
		}
	}

	// Causes the current player to attempt to play the given move. Returns this.
	function play(move) {
		row = move[0];
		col = move[1];
		if (this.isValidMove(move)) {
			deltas = [[1, 0], [-1, 0], [0, 1], [0, -1], [1, 1], [-1, 1], [1, -1], [-1, -1]];
			for (i = 0; i < deltas.length; ++i) {
				dRow = deltas[i][0];
				dCol = deltas[i][1];

				fRow = row + dRow;
				fCol = col + dCol;
				foundOther = false;
				while (fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == -this.currentPlayer) {
					foundOther = true;
					fRow += dRow;
					fCol += dCol;
				}
				if (foundOther && fRow >= 0 && fRow < N && fCol >= 0 && fCol < N && this.board[fRow][fCol] == this.currentPlayer) {
					writeRow = row + dRow;
					writeCol = col + dCol;
					while (writeRow != fRow || writeCol != fCol) {
						this.board[writeRow][writeCol] = this.currentPlayer;
						writeRow += dRow;
						writeCol += dCol;
					}
				}
			}

			this.board[row][col] = this.currentPlayer;
			this.currentPlayer = -this.currentPlayer;

			this.passed = false;

			this.refreshValidMoves();
		}
		return this;
	}

	// Causes the current player to pass, ending the game if the previous player also passed. Returns this.
	function pass() {
		this.currentPlayer = -this.currentPlayer;
		if (this.passed) {
			this.gameOver = true;
		} else {
			this.passed = true;
			this.refreshValidMoves();
		}
		return this;
	}

	// Computes the number of pieces for each player as a dictionary from player to pieces.
	function getScores() {
		score = {BLACK: 0, WHITE: 0};
		for (row = 0; row < N; ++row) {
			for (col = 0; col < N; ++col) {
				space = this.board[row][col];
				if (space != 0) {
					++score[space];
				}
			}
		}
		return score;
	}

	// Draws the game board and move hints.
	function draw() {
		Graphics2D.Draw.fill(0, 64, 0);
		// Draw the board and pieces.
		for (row = 0; row < N; ++row) {
			for (col = 0; col < N; ++col) {
				// Draw box.
				left = 1 + col * CELL_WIDTH;
				top = 1 + row * CELL_HEIGHT;
				Graphics2D.Draw.rectangle(left, top, CELL_WIDTH - 2, CELL_HEIGHT - 2, 0, 128, 0);
				// Draw piece.
				if (this.board[row][col] != 0) {
					left = col * CELL_WIDTH + CELL_PADDING;
					top = row * CELL_HEIGHT + CELL_PADDING;
					width = CELL_WIDTH - 2 * CELL_PADDING;
					height = CELL_HEIGHT - 2 * CELL_PADDING;
					color = this.board[row][col] == BLACK ? [0, 0, 0] : [255, 255, 255];
					Graphics2D.Draw.ellipse(left, top, width, height, color[0], color[1], color[2]);
				}
			}
		}
		if (this.gameOver) {
			// TODO: Only render scores once when the game ends.
			
			scores = this.getScores();

			blackScoreImage = Font.black.render("Black: " + scores[BLACK]);
			whiteScoreImage = Font.white.render("White: " + scores[WHITE]);

			Graphics2D.Draw.rectangle(0, 0, blackScoreImage.width, blackScoreImage.height, 255, 255, 255, 192);
			blackScoreImage.draw(0, 0);
			
			Graphics2D.Draw.rectangle(0, blackScoreImage.height, whiteScoreImage.width, whiteScoreImage.height, 0, 0, 0, 192);
			whiteScoreImage.draw(0, blackScoreImage.height);
		} else {
			// Draw valid moves.
			for (i = 0; i < this.validMoves.length; ++i) {
				row = this.validMoves[i][0];
				col = this.validMoves[i][1];
				color = this.currentPlayer == BLACK ? [0, 96, 0] : [64, 160, 64];
				left = col * CELL_WIDTH + CELL_PADDING;
				top = row * CELL_HEIGHT + CELL_PADDING;
				width = CELL_WIDTH - 2 * CELL_PADDING;
				height = CELL_HEIGHT - 2 * CELL_PADDING;
				Graphics2D.Draw.ellipse(left, top, width, height, color[0], color[1], color[2]);
			}
		}
	}
}
